# 9.7.9.3. Data Movement and Conversion Instructions: mov

#### 9.7.9.3. [Data Movement and Conversion Instructions: `mov`](https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov)[](https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-mov "Permalink to this headline")

`mov`

Set a register variable with the value of a register variable or an immediate value. Take the
non-generic address of a variable in global, local, or shared state space.

Syntax

```
mov.type  d, a;
mov.type  d, sreg;
mov.type  d, avar;       // get address of variable
mov.type  d, avar+imm;   // get address of variable with offset
mov.u32   d, fname;      // get address of device function
mov.u64   d, fname;      // get address of device function
mov.u32   d, kernel;     // get address of entry function
mov.u64   d, kernel;     // get address of entry function

.type = { .pred,
          .b16, .b32, .b64,
          .u16, .u32, .u64,
          .s16, .s32, .s64,
                .f32, .f64 };
```

Copy to clipboard

Description

Write register `d` with the value of `a`.

Operand `a` may be a register, special register, variable with optional offset in an addressable
memory space, or function name.

For variables declared in `.const`, `.global`, `.local`, and `.shared` state spaces, `mov`
places the non-generic address of the variable (i.e., the address of the variable in its state
space) into the destination register. The generic address of a variable in `const`, `global`,
`local`, or `shared` state space may be generated by first taking the address within the state
space with `mov` and then converting it to a generic address using the `cvta` instruction;
alternately, the generic address of a variable declared in `const`, `global`, `local`, or
`shared` state space may be taken directly using the `cvta` instruction.

Note that if the address of a device function parameter is moved to a register, the parameter will
be copied onto the stack and the address will be in the local state space.

Semantics

```
d = a;
d = sreg;
d = &avar;        // address is non-generic; i.e., within the variable's declared state space
d = &avar+imm;
```

Copy to clipboard

Notes

* Although only predicate and bit-size types are required, we include the arithmetic types for the
  programmer’s convenience: their use enhances program readability and allows additional type
  checking.
* When moving address of a kernel or a device function, only `.u32` or `.u64` instruction types
  are allowed. However, if a signed type is used, it is not treated as a compilation error. The
  compiler issues a warning in this case.

PTX ISA Notes

Introduced in PTX ISA version 1.0.

Taking the address of kernel entry functions requires PTX ISA version 3.1 or later. Kernel function
addresses should only be used in the context of CUDA Dynamic Parallelism system calls. See the *CUDA
Dynamic Parallelism Programming Guide* for details.

Target ISA Notes

`mov.f64` requires `sm_13` or higher.

Taking the address of kernel entry functions requires `sm_35` or higher.

Examples

```
mov.f32  d,a;
mov.u16  u,v;
mov.f32  k,0.1;
mov.u32  ptr, A;        // move address of A into ptr
mov.u32  ptr, A[5];     // move address of A[5] into ptr
mov.u32  ptr, A+20;     // move address with offset into ptr
mov.u32  addr, myFunc;  // get address of device function 'myFunc'
mov.u64  kptr, main;    // get address of entry function 'main'
```

Copy to clipboard